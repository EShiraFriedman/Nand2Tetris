class Graph {

	/** Constructs a new graph */
  constructor Graph new() {
    return this;
  }

  function void drawPixel(Coord coord) {
    if (coord.isValidCoord()) {
      do Screen.drawPixel(coord.x(), coord.y());
    }
      return;
  }

  function void drawGraph() {
		return;
  }

	/** Draws x- and y-axes with arrows */
	function void drawAxes() {
    // x-axis
    do Screen.drawLine(255, 0, 255, 255);

    // y-axis
    do Screen.drawLine(0, 127, 511, 127);

    // left arrow
    do Screen.drawLine(4, 124, 0, 127);
    do Screen.drawLine(4, 130, 0, 127);

    // right arrow
    do Screen.drawLine(507, 124, 511, 127);
    do Screen.drawLine(507, 130, 511, 127);

    // top arrow
    do Screen.drawLine(252, 4, 255, 0);
    do Screen.drawLine(258, 4, 255, 0);

    // bottom arrow
    do Screen.drawLine(252, 251, 255, 255);
    do Screen.drawLine(258, 251, 255, 255);

    return;
  }

  function void drawPoint(Int x, Int y) {
    var Point p;
    var Coord c;
    let p = Point.new(x, y);
    let c = p.toCoord();
    do Graph.drawPixel(c);
    return;
  }


  function void drawLine(Equation equation) {
    var Fraction slope;
    var Int xIncrease, yIncrease, x, y;
    var Point start, end, curr;
    let slope = equation.getSlope();
    let xIncrease = slope.denominator();
    let yIncrease = slope.numerator();
    let start = equation.getLowestPoint();
    let end = equation.getHighestPoint();
    let x = start.x();
    let y = start.y();
    while(x.isLessThan(end.x())){
      do Graph.drawPoint(x, y);
      let x = Int.add(x, xIncrease);
      let y = Int.add(y, yIncrease);
      do Sys.wait(10);
    }
		return;
  }


	function Point getStartingLeftPoint(Fraction scale, Equation e) {
		var Fraction y, x, two55;
		var Int xInt, yInt;
		var Point p;
		let two55 = Fraction.new(Int.new(false, 255), Int.new(true, 1));
		let x = two55.dividedBy(scale);
		let y = e.solveForY(x);
		let xInt = Int.new(x.pos(), x.numerator()/x.denominator());
   	let yInt = Int.new(y.pos(), y.numerator()/y.denominator());
   	let p = Point.new(xInt, yInt);
		return p;
	}

	function Point getEndingRightPoint(Fraction scale, Equation e) {
  		var Fraction y, x, two55;
  		var Int xInt, yInt;
  		var Point p;
  		let two55 = Fraction.new(Int.new(true, 255), Int.new(true, 1));
  		let x = two55.dividedBy(scale);
  		let y = e.solveForY(x);
  		let xInt = Int.new(x.pos(), x.numerator()/x.denominator());
   		let yInt = Int.new(y.pos(), y.numerator()/y.denominator());
   		let p = Point.new(xInt, yInt);
  		return p;
  	}

	function Point getStartingBottomPoint(Fraction scale, Equation e) {
		var Fraction y, x, one27;
		var Int xInt, yInt;
  		var Point p;
        let one27 = Fraction.new(Int.new(false, 127), Int.new(true, 1));
  		let y = one27.dividedBy(scale);
  		let x = e.solveForX(y);
  		let xInt = Int.new(x.pos(), x.numerator()/x.denominator());
  		let yInt = Int.new(y.pos(), y.numerator()/y.denominator());
  		let p = Point.new(xInt, yInt);
  		return p;
	}

	function Point getEndingTopPoint(Fraction scale, Equation e) {
  		var Fraction y, x, one27;
  		var Int xInt, yInt;
    	var Point p;
   		let one27 = Fraction.new(Int.new(true, 127), Int.new(true, 1));
        let y = one27.dividedBy(scale);
    	let x = e.solveForX(y);
    	let xInt = Int.new(x.pos(), x.numerator()/x.denominator());
    	let yInt = Int.new(y.pos(), y.numerator()/y.denominator());
    	let p = Point.new(xInt, yInt);
    	return p;
  	}

// TODO: CONTINUE FROM HERE - CONVERTING EVERYTHING TO USE MY NEW INT OBJECT
  function void getScaledLine(Equation e) {
    var Fraction yIncpt, xIncpt, xIncptTwice, limXAxis, limYAxis, scale, comparator, CUTOFF, scaledX, scaledY, TWOFIFTYFIVE, ONETWENTYSEVEN, TWO;
    var int scaledXIncpt, scaledYIncpt;
    let yIncpt = e.getYIntercept();
    let xIncpt = e.getXIntercept();
		do yIncpt.checkValid();
		do xIncpt.checkValid();
    let TWOFIFTYFIVE = Fraction.new(Int.new(true, 255), Int.new(true, 1));
    let ONETWENTYSEVEN = Fraction.new(Int.new(true, 127), Int.new(true, 1));
		let CUTOFF = Fraction.new(Int.new(true, 3), Int.new(true, 2));
		let TWO = Fraction.new(Int.new(true, 2), Int.new(true, 1));
		let xIncptTwice = xIncpt.times(TWO);
		if(xIncptTwice.isGreaterThan(yIncpt)){
			let limXAxis = CUTOFF.times(xIncpt);
			let limYAxis = CUTOFF.times(xIncpt.dividedBy(TWO));
			let scale = TWOFIFTYFIVE.dividedBy(limXAxis);
			let comparator = limXAxis;
		} else {
			let limYAxis = CUTOFF.times(yIncpt);
     	let limXAxis = CUTOFF.times(yIncpt.times(TWO));
 			let scale = ONETWENTYSEVEN.dividedBy(limYAxis);
 			let comparator = limYAxis;
		}
		let scaledX = xIncpt.times(scale);
		let scaledY = yIncpt.times(scale);
		let scaledXIncpt=scaledX.toInt();
		let scaledYIncpt=scaledY.toInt();
//		do Out.ln(limYAxis.toString());
//		do Out.ln(limXAxis.toString());
//		do Out.ln(scale.toString());
//		do Out.ln(comparator.toString());
return;
  }
}


/**
(Get xIncpt and yIncpt)
if either is <.0001 or >10000, throw an error (it may already do that)
(Let cutoff=1.5 or other const)
 (if(2xIncpt>yIncpt)
        limXAxis=cutoff*xIncpt
        limYAxis=cutoff*xIncpt/2;
        scale=256/limXAxis;
        h2=limXAxis
else
        limYAxis=cutoff*yIncpt;
        limXAxis=cutoff*yIncpt*2
        scale=128/limYAxis;
        h2=limYAxis
        )
get scaledIncpts
get tickmarks

get x of -limXAxis if xincept is greatest
get y of -limYAxis if yincept is greatest
from each until the positives of those, plot each point through to the end of the line





needs a floor function

get scaledIncpts(
scaledXIncpt=floor(xIncpt*scale)
scaledYIncpt=floor(yIncpt*scale)


get tick marks:

tickDist=if(H2<0.0001, "too small", if(H2<0.001, 0.0001 , if(H2<0.01, 0.001, if(H2<0.1, 0.01, if(H2<1, 0.1, if(H2<10, 1, if(H2<100, 10, if(H2<1000, 100, if(H2<10000, 1000, "too high")))))))))
scaledTickDist=tickDist*scale

let dist=scaledTickDist,
while dist < 256
        draw tickmark going up down at dist,0
        draw tickmark going up down at -dist,0
        if dist < 128
                draw tickmark going left right at 0, dist
                draw tickmark going left right at 0, -dist
        increase dist by scaledTickDist

}*/
