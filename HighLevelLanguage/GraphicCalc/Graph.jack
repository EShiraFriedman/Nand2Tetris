class Graph {

	/** Constructs a new graph */
  constructor Graph new() {
    return this;
  }

  function void drawPoint(Point p) {
    var Coord c;
    let c = p.toCoord();
    do Graph.drawPixel(c);
    do Memory.deAlloc(p);
    do Memory.deAlloc(c);
    do Sys.wait(500);
    return;
  }

  function void drawPixel(Coord coord) {
    if (coord.isValidCoord()) {
      do Screen.drawPixel(coord.x(), coord.y());
    }
      return;
  }

	/** Draws x- and y-axes with arrows */
	function void drawAxes() {
    // x-axis
    do Screen.drawLine(255, 0, 255, 255);

    // y-axis
    do Screen.drawLine(0, 127, 511, 127);

    // left arrow
    do Screen.drawLine(4, 124, 0, 127);
    do Screen.drawLine(4, 130, 0, 127);

    // right arrow
    do Screen.drawLine(507, 124, 511, 127);
    do Screen.drawLine(507, 130, 511, 127);

    // top arrow
    do Screen.drawLine(252, 4, 255, 0);
    do Screen.drawLine(258, 4, 255, 0);

    // bottom arrow
    do Screen.drawLine(252, 251, 255, 255);
    do Screen.drawLine(258, 251, 255, 255);

    return;
  }


	/** Draws a line using an equation scaled to fit within (-255, -127) to (255, 127) */
	function void drawScaledLine(Equation equation) {
		var Int x, y, oneI, zeroI, diffInt;
		var Fraction xF, yF, one, tff, ots, diff, pF;
		var Point p;
//		var String pS;
		var boolean continue;
		if (equation.getStartLineNegative()){
			let one = Fraction.new(Int.new(true, 1), Int.new(true, 1));
			let tff = Fraction.new(Int.new(false, 255), Int.new(true, 1));
			let ots = Fraction.new(Int.new(false, 127), Int.new(true, 1));
		} else {
			let one = Fraction.new(Int.new(false, 1), Int.new(true, 1));
			let tff = Fraction.new(Int.new(true, 255), Int.new(true, 1));
			let ots = Fraction.new(Int.new(true, 127), Int.new(true, 1));
		}
		let zeroI = Int.new(true, 0);
		let continue = true;
		if (equation.getXIsScreenCutoff()) {
			let xF = tff;
//			do xF.setPos(false);
			do Out.ln("using X");
			while(continue){
				let yF = equation.solveForY(xF);
				let y = Int.new(yF.pos(), yF.toInt());
				let x = Int.new(xF.pos(), xF.toInt());
				let p = Point.new(x, y);
				do Graph.drawPoint(p);
//				let pF = Fraction.new(x, y);
				do y.dispose();
				do x.dispose();
				do p.dispose();
				let xF = xF.plus(one);
				let diff = xF.minus(tff);
				let diffInt = Int.new(diff.pos(), diff.toInt());
				if (equation.getStartLineNegative()){
					let continue = diffInt.isGreaterThan(zeroI);
				} else {
					let continue = diffInt.isLessThan(zeroI);
				}
			}
		} else {
			do Out.ln("using y");
			let yF = ots;
//			do yF.setPos(false);
			while(continue){
    	  let xF = equation.solveForX(yF);
   			let x = Int.new(xF.pos(), xF.toInt());
        let y = Int.new(yF.pos(), yF.toInt());
        let p = Point.new(x, y);
				do Graph.drawPoint(p);
//let pF = Fraction.new(x, y);
//				do Out.ln(pF.toString());
//				let pS = p.toString();
//				do Out.ln(pS);
	do y.dispose();
				do x.dispose();
				do p.dispose();
   			let yF = yF.plus(one);
        let diff = yF.minus(ots);
        let diffInt = Int.new(diff.pos(), diff.toInt());
        if (equation.getStartLineNegative()){
        					let continue = diffInt.isGreaterThan(zeroI);
        				} else {
        					let continue = diffInt.isLessThan(zeroI);
        				}
//        let continue = diffInt.isGreaterThan(zeroI);
      }
		}
		return;
	}

	/** Returns an equation comparable to the given equation but scaled to fit within (-255, -127) to (255, 127) */
  function Equation getScaledLine(Equation e) {
    var Fraction yIncpt, xIncpt, xIncptTwice, limXAxis, limYAxis, scale, slope, CUTOFF, scaledXIncpt,
    scaledYIncpt, scaledSlope, TWOFIFTYFIVE, ONETWENTYSEVEN, TWO, NEGTWOFIFTYFIVE, NEGONETWENTYSEVEN;
    var Equation scaledEquation;
    var boolean xIsGreater, startNegative;

		let CUTOFF = Fraction.new(Int.new(true, 3), Int.new(true, 2));
    let TWOFIFTYFIVE = Fraction.new(Int.new(true, 255), Int.new(true, 1));
    let NEGTWOFIFTYFIVE = Fraction.new(Int.new(false, 255), Int.new(true, 1));
    let ONETWENTYSEVEN = Fraction.new(Int.new(true, 127), Int.new(true, 1));
    let NEGONETWENTYSEVEN = Fraction.new(Int.new(false, 127), Int.new(true, 1));
		let TWO = Fraction.new(Int.new(true, 2), Int.new(true, 1));

    let yIncpt = e.getYIntercept();
    let xIncpt = e.getXIntercept();
		do yIncpt.checkValid();
		do xIncpt.checkValid();
		let xIncptTwice = xIncpt.times(TWO);

		if(xIncptTwice.isGreaterThan(yIncpt)){
			let xIsGreater = true;
			let limXAxis = CUTOFF.times(xIncpt);
			let limYAxis = CUTOFF.times(xIncpt.dividedBy(TWO));
			let scale = TWOFIFTYFIVE.dividedBy(limXAxis);
			let startNegative = ~yIncpt.pos();
		} else {
			let xIsGreater = false;
			let limYAxis = CUTOFF.times(yIncpt);
     	let limXAxis = CUTOFF.times(yIncpt.times(TWO));
 			let scale = ONETWENTYSEVEN.dividedBy(limYAxis);
 			let startNegative = ~xIncpt.pos();
		}

		let scaledXIncpt = xIncpt.times(scale);
		let scaledYIncpt = yIncpt.times(scale);
		let slope = e.getSlope();
		let scaledSlope = slope.times(scale);
		let scaledEquation = Equation.new(1, "P");
		do scaledEquation.setX(scaledXIncpt);
		do scaledEquation.setY(scaledXIncpt);
		do scaledEquation.setSlope(scaledSlope);
		do scaledEquation.setXIsScreenCutoff(xIsGreater);
		do scaledEquation.setStartLineNegative(startNegative);

    return scaledEquation;
  }
}


/**
(Get xIncpt and yIncpt)
if either is <.0001 or >10000, throw an error (it may already do that)
(Let cutoff=1.5 or other const)
 (if(2xIncpt>yIncpt)
        limXAxis=cutoff*xIncpt
        limYAxis=cutoff*xIncpt/2;
        scale=256/limXAxis;
        h2=limXAxis
else
        limYAxis=cutoff*yIncpt;
        limXAxis=cutoff*yIncpt*2
        scale=128/limYAxis;
        h2=limYAxis
        )
(get scaledIncpts)
get tickmarks

get x of -limXAxis if xincept is greatest = -15*17
get y of -limYAxis if yincept is greatest = -7.5*17
from either that x or that y, solve for the missing value (y or x) and plot that point,
repeatedly increasing by 1 pixel to and resolving with the new value, through to the other edge of the screen

(needs a floor function) (just using division, for now)

(get scaledIncpts(
scaledXIncpt=floor(xIncpt*scale)
scaledYIncpt=floor(yIncpt*scale))


get tick marks:

tickDist=if(H2<0.0001, "too small", if(H2<0.001, 0.0001 , if(H2<0.01, 0.001, if(H2<0.1, 0.01, if(H2<1, 0.1, if(H2<10, 1, if(H2<100, 10, if(H2<1000, 100, if(H2<10000, 1000, "too high")))))))))
scaledTickDist=tickDist*scale

let dist=scaledTickDist,
while dist < 256
        draw tickmark going up down at dist,0
        draw tickmark going up down at -dist,0
        if dist < 128
                draw tickmark going left right at 0, dist
                draw tickmark going left right at 0, -dist
        increase dist by scaledTickDist

}*/
