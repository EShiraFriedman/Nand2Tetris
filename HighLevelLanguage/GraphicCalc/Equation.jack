class Equation {
	field int degree;
	field boolean xExists, yExists, bExists, mExists, xIsScreenCutoff, startLineNegative, isVertical, isHorizontal, isXAxis, isYAxis;
	field String format;
	field Fraction xF, yF, bF, mF, scale;
	static Fraction xCalc, yCalc, bCalc, newSlope, newB, mx, tempCalc1, tempCalc2, tempCalc3, tempCalc4, tempCalc5;
	static Int calc1, calc2, calc3, calc4, calc5, calc6;

	/** Constructs a new equation for graphing */
	constructor Equation new(int deg, String form) {
		let xExists = false;
		let yExists = false;
		let bExists = false;
		let mExists = false;
		let isVertical = false;
		let isHorizontal = false;
		let isXAxis = false;
		let isYAxis = false;
		let scale = Fraction.new(Const.i1(), Const.i1());
		let degree = deg;
		let format = form;
		return this;
	}

	/** Initiates static variables */
	function void init() {
		let xCalc = Fraction.new(Const.i1(), Const.i1());
		let yCalc = Fraction.new(Const.i1(), Const.i1());
		let bCalc = Fraction.new(Const.i1(), Const.i1());
		let newSlope = Fraction.new(Const.i1(), Const.i1());
		let newB = Fraction.new(Const.i1(), Const.i1());
		let mx = Fraction.new(Const.i1(), Const.i1());
		let tempCalc1 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc2 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc3 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc4 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc5 = Fraction.new(Const.i1(), Const.i1());
		let calc1 = Int.new(true, 1);
		let calc2 = Int.new(true, 1);
		let calc3 = Int.new(true, 1);
		let calc4 = Int.new(true, 1);
		let calc5 = Int.new(true, 1);
		let calc6 = Int.new(true, 1);
		return;
	}

	/** Disposes static variables */
	function void deInit() {
		do xCalc.dispose();
		do yCalc.dispose();
		do bCalc.dispose();
		do newSlope.dispose();
		do newB.dispose();
		do mx.dispose();
		do tempCalc1.dispose();
		do tempCalc2.dispose();
		do tempCalc3.dispose();
		do tempCalc4.dispose();
		do tempCalc5.dispose();
		do calc1.dispose();
		do calc2.dispose();
		do calc3.dispose();
		do calc4.dispose();
		do calc5.dispose();
		do calc6.dispose();
		return;
	}

	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	/** Accessors */
	method Fraction getX(){ return xF; }
	method Fraction getY(){ return yF; }
	method Fraction getB(){ return bF; }
	method Fraction getSlope(){ return mF; }
	method Fraction getScale(){ return scale; }
	method boolean getXIsScreenCutoff(){ return xIsScreenCutoff; }
	method boolean getStartLineNegative(){ return startLineNegative; }
	method boolean getIsVertical(){ return isVertical; }
	method boolean getIsHorizontal(){ return isHorizontal; }
	method boolean getIsXAxis(){ return isXAxis; }
	method boolean getIsYAxis(){ return isYAxis; }
	method String getFormat(){ return format; }
	method void setX(Fraction xSet){
		let xF = xSet;
		let xExists = true;
		return;
	}
	method void setY(Fraction ySet){
		let yF = ySet;
		let yExists = true;
		return;
	}
	method void setB(Fraction bSet){
		let bF = bSet;
		let bExists = true;
		return;
	}
	method void setSlope(Fraction mSet){
		let mF = mSet;
		let mExists = true;
		return;
	}
	method void setScale(Fraction sSet){
		let scale = sSet;
		return;
	}
	method void setXIsScreenCutoff(boolean isX){
		let xIsScreenCutoff = isX;
		return;
	}
	method void setStartLineNegative(boolean startNegative){
		let startLineNegative = startNegative;
		return;
	}
	method void setIsVertical(boolean setVert){
		let isVertical = setVert;
		return;
	}
	method void setIsHorizontal(boolean setHor){
		let isHorizontal = setHor;
		return;
	}
	method void setIsXAxis(boolean setXAxis){
		let isXAxis = setXAxis;
		return;
	}
	method void setIsYAxis(boolean setYAxis){
		let isYAxis = setYAxis;
		return;
	}

	/** Turns an equation in the standard or point-slope format into one using the slope-intercept format */
  function Equation convertToSlopeIntercept(Equation e){
    var String f;
    let f = e.getFormat();
    if (S.equals(f, Const.sI())){
      return Equation.setSlopeInterceptDirection(e);
    }
    if (S.equals(f, Const.sP())){
      return Equation.convertFromPointSlopeToSlopeIntercept(e);
    }
    if (S.equals(f, Const.sS())){
      return Equation.convertFromStandardToSlopeIntercept(e);
    }
    return e;
  }

	function Equation setSlopeInterceptDirection(Equation e){
		var Fraction slope, b;
		let slope = e.getSlope();
		let b = e.getB();
		if (slope.equals(Const.f0())){
      do e.setIsHorizontal(true);
      if (b.equals(Const.f0())){
        do e.setIsXAxis(true);
      }
    }
    return e;
	}

	function Equation convertFromPointSlopeToSlopeIntercept(Equation oldE){
		var Equation newE;
		var Fraction O;

		let xCalc = oldE.getX();
    let yCalc = oldE.getY();
    let newE = Equation.new(1, Const.sI());
    let newSlope = oldE.getSlope();
    let O = Const.f0();

		// slope remains the same
    do newE.setSlope(newSlope);

		// neither x, y, or m are 0; y = mx + y1 - mx1
    if (~(newSlope.equals(O) | xCalc.equals(O) | yCalc.equals(O))){
      do Fraction.multiply(newSlope, xCalc, mx, calc1, calc2, calc3, calc4, calc5, calc6);
      do newE.setB(yCalc.minus(mx));
      return newE;
    }

		// x and/or m is 0; y = mx + y1
    if (xCalc.equals(O) | newSlope.equals(O)){
      do newE.setB(yCalc);
      if (newSlope.equals(O)){ // m is 0; y = y1
        do newE.setIsHorizontal(true);
        if (yCalc.equals(O)){ // m and y are 0; y = 0
          do newE.setIsXAxis(true);
        }
      }
      return newE;
    }
		// just y is 0; y = mx - mx1
    do Fraction.multiply(newSlope, xCalc, mx, calc1, calc2, calc3, calc4, calc5, calc6);
    do mx.setPos(~(mx.pos()));
    do newE.setB(mx);
    return newE;
	}

	function Equation convertFromStandardToSlopeIntercept(Equation oldE){
		var Equation newE;
		var Fraction O;

		let xCalc = oldE.getX();
    let yCalc = oldE.getY();
    let bCalc = oldE.getB();
    let newE = Equation.new(1, Const.sI());
    let O = Const.f0();

    if (xCalc.equals(O) & yCalc.equals(O)){ // throw an error if both x and y are 0
      do Sys.error(3);
    }

    if (bCalc.equals(O)) { // if b is 0, it remains 0
      do newE.setB(O);
    }
    if ((xCalc.equals(O) | yCalc.equals(O)) & ~(xCalc.equals(yCalc))){ // x=0 XOR y=0; m becomes 0
      do newE.setSlope(O);
    }
    if (yCalc.equals(O)) { // y is 0
      do newE.setIsVertical(true);
      if (bCalc.equals(O)) { // both y and b are 0
        do newE.setIsYAxis(true);
      } else { // just y is 0
        do newE.setB(bCalc.dividedBy(xCalc));
      }
    } else { // y is not 0
      if (~(bCalc.equals(O))){ // both y and b are not 0; b becomes b/y1
        do newE.setB(bCalc.dividedBy(yCalc));
      }
      if (~(xCalc.equals(O))){ // both y and x are not 0;
        let tempCalc1 = xCalc.dividedBy(yCalc);
        do tempCalc1.setPos(~(tempCalc1.pos()));
        do newE.setSlope(tempCalc1);
      } else { // y is not 0 but x is 0;
        do newE.setIsHorizontal(true);
        if (bCalc.equals(O)) { // y is not 0 but both x and b are 0;
          do newE.setIsXAxis(true);
        }
      }
    }

    return newE;
	}

	/** Uses the value of x to solve for y */ // includes horizontal
  method Fraction solveForY(Fraction xPoint){
    if (isHorizontal){
      return bF;
    }
    if (S.equals(format, Const.sI())){
      do Fraction.multiply(mF, xPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
      let tempCalc2 = tempCalc1.plus(bF);
      return tempCalc2;
    }
    if (S.equals(format, Const.sP())){
      let tempCalc1 = xF.minus(xPoint);
      do Fraction.multiply(mF, tempCalc1, tempCalc2, calc1, calc2, calc3, calc4, calc5, calc6);
      let tempCalc3 = yF.minus(tempCalc2);
      return tempCalc3;
    }
    if (S.equals(format, Const.sS())){
      do Fraction.multiply(xF, xPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
      let tempCalc2 = bF.minus(tempCalc1);
      let tempCalc3 = tempCalc2.dividedBy(yF);
      return tempCalc3;
    }
    do Sys.halt();
    return Const.f1();
  }

	/** Uses the value of y to solve for x */
	method Fraction solveForX(Fraction yPoint){ // includes vertical
		if (isVertical){
			return bF;
		}
		if (S.equals(format, Const.sI())){
			let tempCalc1 = yPoint.minus(bF);
			let tempCalc2 = tempCalc1.dividedBy(mF);
			return tempCalc2;
		}
		if (S.equals(format, Const.sP())){
			let tempCalc1 = yF.minus(yPoint);
			let tempCalc2 = tempCalc1.dividedBy(mF);
			let tempCalc3 = xF.minus(tempCalc2);
			return tempCalc3;
		}
		if (S.equals(format, Const.sS())){
			do Fraction.multiply(yF, yPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
			let tempCalc2 = bF.minus(tempCalc1);
			let tempCalc3 = tempCalc2.dividedBy(xF);
			return tempCalc3;
		}
		return Fraction.new(0, 1);
	}

	method Fraction getYIntercept(){
		do tempCalc1.set(Const.i0(), Const.i1());
		let tempCalc2 = solveForY(tempCalc1);
		return tempCalc2;
	}

	method Fraction getXIntercept(){
		do tempCalc1.set(Const.i0(), Const.i1());
		let tempCalc2 = solveForX(tempCalc1);
		return tempCalc2;
	}


	/****************************************************
	**  Methods to build the equation with user input  **
	****************************************************/

	/** Stores the appropriate values from the user based on the chosen equation format */
	method void getValues(){
		if (S.equals(format, Const.sP())){
			do inputVar(Const.sY());
			do inputVar(Const.sM());
			do inputVar(Const.sX());
			return;
		}
		if (S.equals(format, Const.sI())){
			do inputVar(Const.sM());
			do inputVar(Const.sB());
			return;
		}
		if (S.equals(format, Const.sS())){
			do inputVar(Const.sX());
			do inputVar(Const.sY());
			while (xF.equals(Const.f0()) & yF.equals(Const.f0())){
				do Out.ln("x and y cannot both be 0. Please choose another number.");
				do inputVar(Const.sY());
			}
			do inputVar(Const.sB());
			return;
		}
		return;
	}

	/** Retrieves a single value from the user */
	method void inputVar(String v){
		var String xString, yString, bString, mString;
		var Fraction temp;
		if (S.equals(v, Const.sX())){
			let xString = Keyboard.readLine("Enter an x:");
			let xF = Fraction.toFraction(xString);
			let temp = xF;
			let xExists = true;
		}
		if (S.equals(v, Const.sY())){
			let yString = Keyboard.readLine("Enter a y:");
			let yF = Fraction.toFraction(yString);
			let yExists = true;
			let temp = yF;
		}
		if (S.equals(v, Const.sB())){
			let bString = Keyboard.readLine("Enter an intercept:");
			let bF = Fraction.toFraction(bString);
			let bExists = true;
			let temp = bF;
		}
		if (S.equals(v, Const.sM())){
			let mString = Keyboard.readLine("Enter a slope:");
			let mF = Fraction.toFraction(mString);
			let mExists = true;
			let temp = mF;
		}
		return;
	}


	/************************************************************************************
	**  Methods to create a string version of the equation for printing to the screen  **
	************************************************************************************/

	/** Returns the current state of the equation as a string based on the chosen equation format */
	method String toString(){
		if (degree = 1){
			if (S.equals(format, Const.sS())){
				return getStandardString();
			}
			if (S.equals(format, Const.sI())){
				return getSlopeInterceptString();
			}
			if (S.equals(format, Const.sP())){
				return getPointSlopeString();
			}
		}
		return "x";
	}

	/** Returns a string version of the equation in slope-intercept form: y = mx + b */
	method String getSlopeInterceptString(){
		var String mS, bS, plusMinusB, stringified;
		if (mExists){
			let mS = Equation.simplifyMX(mF, "x");
		} else {
			let mS = "_";
		}
		if (bExists){
			let plusMinusB = Equation.simplifySecondTerm(bF);
		} else {
			let bS = " + _";
		}
		let stringified = S.append3("y = ", mS, plusMinusB);
		return stringified;
	}

	/** Returns a string version of the equation in point-slope form: (y - y1) = m(x - x1) */
	method String getPointSlopeString(){
		var String plusMinusY, plusMinusX, fullX, mTermS, stringified;
		var Fraction negY, negX;
		if (yExists){
			let negY = yF;
			do negY.setPos(~(yF.pos()));
			let plusMinusY = Equation.simplifySecondTerm(negY);
		} else {
			let plusMinusY = " - _";
		}
		if (xExists){
			let negX = xF;
			do negX.setPos(~(xF.pos()));
			let plusMinusX = Equation.simplifySecondTerm(negX);
			let fullX = S.append3("(x", plusMinusX, ")");
    } else {
      let fullX = "(x - _)";
    }
		if (mExists){
			let mTermS = Equation.simplifyMX(mF, fullX);
		} else {
			let mTermS = S.append("_", fullX);
		}

		let stringified = S.append4("y", plusMinusY, " = ", mTermS);
		return stringified;
	}

	/** Returns a string version of the equation in standard form: x1x + y1y = b */
	method String getStandardString(){
		var String xS, plusMinusY, bS, stringified;
		if (xExists){

			let xS = Equation.simplifyMX(xF, "x");
		} else {
			let xS = "_";
		}
		if (yExists){
			let plusMinusY = Equation.simplifySecondYTerm(xF, yF);
		} else {
			let plusMinusY = " + _";
		}
		if (bExists){
			let bS = bF.toString();
		} else {
			let bS = "_";
		}
		let stringified = S.append4(xS, plusMinusY, " = ", bS);
		return stringified;
	}

	function String simplifyMX(Fraction m, String x){
    var String mS, d, n;
    if (m.equals(Const.f1())){ // y = x + b or y - y1 = (x - x1)
      return x;
    }
    if (m.equals(Const.fNeg1())){ // y = -x + b or y - y1 = -(x - x1)
      return S.append("-", x);
    }
    if (m.numerator() = 0){
      if (x.length() > 1){ // y - y1 = 0
        return "0";
      } // y = b
      return "";
    }
    if (m.numerator() = 1){
      let d = String.new(6);
      do d.setInt(m.denominator());
      if (m.pos() = true){ // y = x/d + b or y - y1 = (x - x1)/d
        return S.append3(x, "/", d);
      } // y = -x/d + b or y - y1 = -(x - x1)/d
      return S.append4("-", x, "/", d);
    }
    if (~(m.denominator() = 1)){
      let n = String.new(6);
      let d = String.new(6);
      do n.setInt(m.numerator());
      do d.setInt(m.denominator());
      if (m.pos() = true){ // y = nx/d + b or y - y1 = n(x - x1)/d
        return S.append4(n, x, "/", d);
      } // y = -nx/d + b or y - y1 = -n(x - x1)/d
      return S.append5("-", n, x, "/", d);
    }
    let mS = m.toString();
    return S.append(mS, x); // m is not a fraction, 1, -1, or 0 (y = mx + b or y - y1 = m(x - x1))
  }

  function String simplifySecondTerm(Fraction fraction){ // turns into " - n" or " + n"
    var String plusMinusF, sF;
    var Fraction posF;
    if (fraction.numerator() = 0){
      return "";
    }
    if (fraction.pos() = true){
      let sF = fraction.toString();
      let plusMinusF = S.append(" + ", sF);
    } else {
      let posF = fraction;
      do posF.setPos(true);
      let sF = posF.toString();
      let plusMinusF = S.append(" - ", sF);
    }
    return plusMinusF;
  }

  function String simplifySecondYTerm(Fraction x, Fraction y){ // turns into " - ny" or " + ny"
    var String plusMinusY, sY;
    var Fraction posY;
    if (y.numerator() = 0){
      return "";
    }
    if (y.pos() = true){
      let sY = Equation.simplifyMX(y, "y");
      if (x.equals(Const.f0())){
        let plusMinusY = sY;
      } else {
        let plusMinusY = S.append(" + ", sY);
      }
    } else {
      let posY = y;
      do posY.setPos(true);
      let sY = Equation.simplifyMX(posY, "y");
      if (x.equals(Const.f0())){
        let plusMinusY = sY;
      } else {
        let plusMinusY = S.append(" - ", sY);
      }
    }
    return plusMinusY;
  }
}
