class Equation {
  field Fraction x, y, m, b;
  field int degree;
  field boolean xExists, yExists, bExists, mExists;
  field String format;

	/** Constructs a new equation for graphing */
  constructor Equation new(int deg, String form) {
    let xExists = false;
    let yExists = false;
    let bExists = false;
    let mExists = false;
    let degree = deg;
    let format = form;
    return this;
  }

	/** Uses a value of x to solve for y */
	method Fraction solveForY(int xPoint) {
		var Fraction xFrac, yFrac, step1, step2;
		var String xS;
		let xS = xPoint;
		let yFrac = Fraction.new(1, 1);
    let xFrac = Fraction.toFraction(xS);
		if (S.equals(format, "I")){
			let step1 = m.times(xFrac);
			let yFrac = step1.plus(b);
			return yFrac;
		}
		if (S.equals(format, "P")){
			let step1 = x.minus(xFrac);
			let step2 = m.times(step1);
			let yFrac = y.minus(step2);
			return yFrac;
    }
    if (S.equals(format, "O")){
      let step1 = x.times(xFrac);
      let step2 = b.minus(step1);
      let yFrac = step2.dividedBy(y);
      return yFrac;
    }
    return xFrac;
	}

	/** Uses a value of y to solve for x */
	method Fraction solveForX(int yPoint) {
		var Fraction yFrac, xFrac, step1, step2;
		var String yS;
		let yS = yPoint;
		let xFrac = Fraction.new(1, 1);
		let yFrac = Fraction.toFraction(yS);
		if (S.equals(format, "I")){
			let step1 = yFrac.minus(b);
			let xFrac = step1.dividedBy(m);
		}
		if (S.equals(format, "P")){
			let step1 = y.minus(yFrac);
			let step2 = x.minus(step1);
			let xFrac = step2.dividedBy(m);
		}
		if (S.equals(format, "O")){
			let step1 = y.times(yFrac);
			let step2 = b.minus(step1);
			let xFrac = step2.dividedBy(x);
		}
		do step1.dispose();
		do step2.dispose();
		return xFrac;
	}


	/****************************************************
	**  Methods to build the equation with user input  **
	****************************************************/

	/** Stores the appropriate values from the user based on the chosen equation format */
	method void getValues(){
		do Screen.clearScreen();
		do Output.moveCursor(0,0);
		if (S.equals(format, "P")){
      do inputVar("y");
      do inputVar("m");
      do inputVar("x");
      return;
    }
		if (S.equals(format, "I")){
			do inputVar("m");
			do inputVar("b");
			return;
		}
		if (S.equals(format, "O")){
      do inputVar("x");
      do inputVar("y");
      do inputVar("b");
      return;
		}
    return;
	}

	/** Retrieves a single value from the user */
  method void inputVar(String v) {
    var String xString, yString, bString, mString;
    do Out.ln(toString());
    if (S.equals(v, "x")){
      let xString = Keyboard.readLine("Enter an x:");
			let x = Fraction.toFraction(xString);
			do xString.dispose();
      let xExists = true;
    }
    if (S.equals(v, "y")){
      let yString = Keyboard.readLine("Enter a y:");
      do Out.ln(yString);
      let y = Fraction.toFraction(yString);
      do yString.dispose();
      let yExists = true;
    }
    if (S.equals(v, "b")){
      let bString = Keyboard.readLine("Enter an intercept:");
      let b = Fraction.toFraction(bString);
      do bString.dispose();
      let bExists = true;
    }
    if (S.equals(v, "m")){
      let mString = Keyboard.readLine("Enter a slope:");
      let m = Fraction.toFraction(mString);
      do mString.dispose();
      let mExists = true;
     }
     do Screen.clearScreen();
     do Output.moveCursor(0,0);
    return;
  }


	/************************************************************************************
	**  Methods to create a string version of the equation for printing to the screen  **
	************************************************************************************/

	/** Returns the current state of the equation as a string based on the chosen equation format */
  method String toString() {
    if (degree = 1){
	    if (S.equals(format, "O")){
	      return oldString();
	    }
	    if (S.equals(format, "I")){
	      return slopeInterceptString();
	    }
	    if (S.equals(format, "P")){
	      return pointSlopeString();
	    }
    }
    return "x";
  }

  /** Returns a string version of the equation in slope-intercept form: y = mx + b */

  method String slopeInterceptString(){
    var String mS, bS, stringified;
    if (mExists){
      let mS = m.toString();
    } else {
      let mS = "_";
    }
    if (bExists){
      let bS = b.toString();
    } else {
      let bS = "_";
    }
		let stringified = S.append4("y = ", mS, "x + ", bS);
    do mS.dispose();
    do bS.dispose();
    return stringified;
  }

  /** Returns a string version of the equation in point-slope form: (y - y1) = m(x - x1) */
  method String pointSlopeString(){
    var String xS, yS, mS, stringified;
    do Out.ln("in pointSlopeString()");
    if (yExists){
      do Out.s("Fraction.toString(y) = ");
      let yS = y.toString();
      do Out.ln(yS);
    } else {
      let yS = "_";
    }
    if (mExists){
      let mS = m.toString();
    } else {
      let mS = "_";
    }
    if (xExists){
      let xS = x.toString();
    } else {
      let xS = "_";
    }
    let stringified = S.append7("(y - ", yS, ") = ", mS, "(x - ", xS, ")");

    do xS.dispose();
    do yS.dispose();
    do mS.dispose();
    return stringified;
  }

	/** Returns a string version of the equation in the old format: cy + dx = b */
  method String oldString(){
    var String xS, yS, bS, stringified;
    if (xExists){
      let xS = x.toString();
    } else {
      let xS = "_";
    }
    if (yExists){
      let yS = y.toString();
    } else {
      let yS = "_";
    }
    if (bExists){
      let bS = b.toString();
    } else {
      let bS = "_";
    }
    let stringified = S.append5(xS, "x + ", yS, "y = ", bS);

    do xS.dispose();
    do yS.dispose();
    do bS.dispose();
    return stringified;
  }
}
