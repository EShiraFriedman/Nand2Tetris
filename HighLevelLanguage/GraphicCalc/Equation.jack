class Equation {
  field int x, y, m, b, degree;
  field boolean xExists, yExists, bExists, mExists, xIsScreenCutoff, startLineNegative;
  field String format;
  field Fraction xF, yF, bF, mF;

	/** Constructs a new equation for graphing */
  constructor Equation new(int deg, String form) {
    let xExists = false;
    let yExists = false;
    let bExists = false;
    let mExists = false;
    let degree = deg;
    let format = form;
    return this;
  }

  /** Accessors */
  method Fraction getX(){ return xF; }
  method Fraction getY(){ return yF; }
  method Fraction getB(){ return bF; }
  method Fraction getSlope(){ return mF; }
  method boolean getXIsScreenCutoff(){ return xIsScreenCutoff; }
  method boolean getStartLineNegative(){ return startLineNegative; }
  method String getFormat(){ return format; }
  method void setX(Fraction xSet){
    let xF = xSet;
    let xExists = true;
    return;
  }
  method void setY(Fraction ySet){
    let yF = ySet;
    let yExists = true;
    return;
  }
  method void setB(Fraction bSet){
    let bF = bSet;
    let bExists = true;
    return;
  }
  method void setSlope(Fraction mSet){
    let mF = mSet;
    let mExists = true;
    return;
  }
	method void setXIsScreenCutoff(boolean isX){
		let xIsScreenCutoff = isX;
		return;
	}
	method void setStartLineNegative(boolean startNegative){
		let startLineNegative = startNegative;
		return;
	}

	/** Uses the value of x to solve for y */
	method Fraction solveForY(Fraction xPoint){
		var Fraction tempCalc1, tempCalc2, tempCalc3;
		if (S.equals(format, "I")){
			let tempCalc1 = mF.times(xPoint);
			let tempCalc2 = tempCalc1.plus(bF);
			do Memory.deAlloc(xPoint);
			do Memory.deAlloc(tempCalc1);
			return tempCalc2;
		}
		if (S.equals(format, "P")){
			let tempCalc1 = xF.minus(xPoint);
			let tempCalc2 = mF.times(tempCalc1);
			let tempCalc3 = yF.minus(tempCalc2);
			do Memory.deAlloc(xPoint);
      do Memory.deAlloc(tempCalc1);
      do Memory.deAlloc(tempCalc2);
			return tempCalc3;
    }
    if (S.equals(format, "S")){
      let tempCalc1 = xF.times(xPoint);
      let tempCalc2 = bF.minus(tempCalc1);
      let tempCalc3 = tempCalc2.dividedBy(yF);
      do Memory.deAlloc(xPoint);
      do Memory.deAlloc(tempCalc1);
      do Memory.deAlloc(tempCalc2);
      return tempCalc3;
    }
    return Fraction.new(0, 1);
	}

	/** Uses the value of y to solve for x */
	method Fraction solveForX(Fraction yPoint){
		var Fraction tempCalc1, tempCalc2, tempCalc3;
		if (S.equals(format, "I")){
			let tempCalc1 = yPoint.minus(bF);
			let tempCalc2 = tempCalc1.dividedBy(mF);
			do Memory.deAlloc(yPoint);
			do Memory.deAlloc(tempCalc1);
			return tempCalc2;
		}
		if (S.equals(format, "P")){
			let tempCalc1 = yF.minus(yPoint);
			let tempCalc2 = tempCalc1.dividedBy(mF);
			let tempCalc3 = xF.minus(tempCalc2);
			do Memory.deAlloc(yPoint);
      do Memory.deAlloc(tempCalc1);
      do Memory.deAlloc(tempCalc2);
			return tempCalc3;
		}
		if (S.equals(format, "S")){
			let tempCalc1 = yF.times(yPoint);
			let tempCalc2 = bF.minus(tempCalc1);
			let tempCalc3 = tempCalc2.dividedBy(xF);
			do Memory.deAlloc(yPoint);
      do Memory.deAlloc(tempCalc1);
      do Memory.deAlloc(tempCalc2);
			return tempCalc3;
		}
		return Fraction.new(0, 1);
	}


	/****************************************************
	**  Methods to build the equation with user input  **
	****************************************************/

	// TODO: either prevent or figure out how to handle an input of 0
	/** Stores the appropriate values from the user based on the chosen equation format */
	method void getValues(){
		if (S.equals(format, "P")){
      do inputVar("y");
      do inputVar("m");
      do inputVar("x");
      return;
    }
		if (S.equals(format, "I")){
			do inputVar("m");
			do inputVar("b");
			return;
		}
		if (S.equals(format, "S")){
      do inputVar("x");
      do inputVar("y");
      do inputVar("b");
      return;
		}
    return;
	}

	/** Retrieves a single value from the user */
  method void inputVar(String v){
    var String xString, yString, bString, mString;
    var Fraction temp;
    if (S.equals(v, "x")){
      let xString = Keyboard.readLine("Enter an x:");
      let xF = Fraction.toFraction(xString);
      let temp = xF;
      do Out.ln(temp.toString());
      let xExists = true;
    }
    if (S.equals(v, "y")){
      let yString = Keyboard.readLine("Enter a y:");
      let yF = Fraction.toFraction(yString);
      let yExists = true;
      let temp = yF;
      do Out.ln(temp.toString());
    }
    if (S.equals(v, "b")){
      let bString = Keyboard.readLine("Enter an intercept:");
      let bF = Fraction.toFraction(bString);
      let bExists = true;
      let temp = bF;
      do Out.ln(temp.toString());
    }
    if (S.equals(v, "m")){
      let mString = Keyboard.readLine("Enter a slope:");
      let mF = Fraction.toFraction(mString);
      let mExists = true;
      let temp = mF;
      do Out.ln(temp.toString());
    }
    return;
  }


	/************************************************************************************
	**  Methods to create a string version of the equation for printing to the screen  **
	************************************************************************************/

	/** Returns the current state of the equation as a string based on the chosen equation format */
  method String toString(){
    if (degree = 1){
	    if (S.equals(format, "S")){
	      return getStandardString();
	    }
	    if (S.equals(format, "I")){
	      return getSlopeInterceptString();
	    }
	    if (S.equals(format, "P")){
	      return getPointSlopeString();
	    }
    }
    return "x";
  }

  /** Returns a string version of the equation in slope-intercept form: y = mx + b */
  method String getSlopeInterceptString(){
    var String mS, bS, stringified;
    if (mExists){
      let mS = mF.toString();
    } else {
      let mS = "_";
    }
    if (bExists){
      let bS = bF.toString();
    } else {
      let bS = "_";
    }
    let stringified = S.append4("y = ", mS, "x + ", bS);
    return stringified;
  }

  /** Returns a string version of the equation in point-slope form: (y - y1) = m(x - x1) */
  method String getPointSlopeString(){
    var String xS, yS, mS, stringified;
    if (yExists){
      let yS = yF.toString();
    } else {
      let yS = "_";
    }
    if (mExists){
			let mS = mF.toString();
    } else {
      let mS = "_";
    }
    if (xExists){
			let xS = xF.toString();
    } else {
      let xS = "_";
    }
		let stringified = S.append7("(y - ", yS, ") = ", mS, "(x - ", xS, ")");
    return stringified;
  }

	/** Returns a string version of the equation in standard form: x1x + y1y = b */
  method String getStandardString(){
    var String xS, yS, bS, stringified;
    if (xExists){
      let xS = xF.toString();
    } else {
      let xS = "_";
    }
    if (yExists){
      let yS = yF.toString();
    } else {
      let yS = "_";
    }
    if (bExists){
      let bS = bF.toString();
    } else {
      let bS = "_";
    }
    let stringified = S.append5(xS, "x + ", yS, "y = ", bS);
    return stringified;
  }

  method Fraction getYIntercept(){
    var Fraction yIntercept, x;
    var Int zero, one;
    let zero = Int.new(true, 0);
    let one = Int.new(true, 1);
    let x = Fraction.new(zero, one);
    let yIntercept = solveForY(x);
    return yIntercept;
  }

  method Fraction getXIntercept(){
    var Fraction xIntercept, y;
    var Int zero, one;
    let zero = Int.new(true, 0);
    let one = Int.new(true, 1);
    let y = Fraction.new(zero, one);
    let xIntercept = solveForX(y);
    return xIntercept;
  }

  function Equation convertToSlopeIntercept(Equation e){
    var String f;
    var Fraction eX, eY, eB, newSlope, newB, mx;
    var Equation slopeIEquation;
    let f = e.getFormat();
    if (S.equals(f, "I")){
      return e;
    }
    let eX = e.getX();
    let eY = e.getY();
    let slopeIEquation = Equation.new(1, "I");
    if (S.equals(f, "S")){
			let newSlope = eX.dividedBy(eY);
			do newSlope.setPos(~newSlope.pos());
			let eB = e.getB();
			let newB = eB.dividedBy(eY);
		} else {
			let newSlope = e.getSlope();
			let mx = newSlope.times(e.getX());
			let newB = eY.minus(mx);
		}
		do slopeIEquation.setSlope(newSlope);
		do slopeIEquation.setB(newB);
		return slopeIEquation;
  }
}
