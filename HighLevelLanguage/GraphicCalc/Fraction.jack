// This class was evolved from a file that is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/09/Fraction/Fraction.jack

// Extended and Modified by Shira Joseph

/**
* Represents the Fraction type and related operations.
*/
class Fraction {
	field int numerator, denominator;
	field boolean pos;

	/** Constructs a (reduced) fraction from the given numerator and denominator. */
	constructor Fraction new(int x, int y) {
		do set(x, y);
		return this;
	}

	/** Initiates static variables */
	function void init(){
		return;
	}

	/** Disposes static variables */
	function void deInit() {
		return;
	}

	/** Accessors. */
	method int numerator(){ return numerator; }
	method int denominator(){ return denominator; }
	method boolean pos(){ return pos; }
	method int signedNumerator(){
		if (pos) {
			return numerator * -1;
		}
		return numerator;
	}

	method void set(int n, int d){
		var boolean nPos, dPos;

		if (d = 0) {
			do Sys.error(3);
		}

		let numerator = n;
		let denominator = d;
		let nPos = true;
		let dPos = true;

		if (numerator < numerator * -1) {
			let nPos = false;
			let numerator = numerator * -1;
		}
		if (denominator < denominator * -1) {
			let dPos = false;
			let denominator = denominator * -1;
		}

		if ((nPos & ~dPos) | (~nPos & dPos)){
			let pos = false;
		} else {
			let pos = true;
		}

		if (n = 0) {
			let denominator = 1;
		} else {
			do reduce();
		}
		return;
	}
	method void setPos(boolean value){
		let pos = value;
		return;
	}

	/** Reduces this fraction. */
  method void reduce() {
    var int g;
    let g = Fraction.gcd(numerator, denominator);
    if (g > 1) {
       let numerator = numerator / g;
       let denominator = denominator / g;
    }
    return;
  }

	/** Stores a + b in this fraction */
	method void setSum(Fraction a, Fraction b) {
		var int numer1, numer2;
		if (~a.pos()) {
			let numer1 = -1 * a.numerator() * b.denominator();
		} else {
			let numer1 = a.numerator() * b.denominator();
		}
		if (~b.pos()) {
			let numer2 = -1 * b.numerator() * a.denominator();
		} else {
			let numer2 = b.numerator() * a.denominator();
		}
		do set(numer1 + numer2, a.denominator() * b.denominator());
		return;
	}

	/** Stores a - b in this fraction */
	method void setDifference(Fraction a, Fraction b) {
		var int numer1, numer2;
		if (~a.pos()) {
      let numer1 = -1 * a.numerator() * b.denominator();
    } else {
      let numer1 = a.numerator() * b.denominator();
    }
    if (~b.pos()) {
      let numer2 = -1 * b.numerator() * a.denominator();
    } else {
      let numer2 = b.numerator() * a.denominator();
    }
    do set(numer1 - numer2, a.denominator() * b.denominator());
    return;
	}

	/** Stores a * b in this fraction */
	method void setProduct(Fraction a, Fraction b) {
		do set(a.numerator() * b.numerator(), a.denominator() * b.denominator());
		if (~(a.pos() = b.pos())){
			do setPos(false);
		}
		return;
	}

	/** Stores a / b in this fraction */
	method void setQuotient (Fraction a, Fraction b) {
		do set(a.numerator() * b.denominator(), a.denominator() * b.numerator());
    if (~(a.pos() = b.pos())){
      do setPos(false);
    }
    return;
	}

	/** Turns a string into a Fraction. Accepts these formats: x, -x, x/y, x\y, -x/y, -x\y, x/-y, x\-y, -x/-y, -x\-y */
	function Fraction toFraction (String num) {
		var int delimiter, forwardSlash, backSlash, n, d, start, end;
		var String nS, dS, num2, num3;
		var char fChar, bChar;

		let fChar = 47;
		let bChar = 92;
		let forwardSlash = S.indexOf(num, fChar);
		let num3 = num;
		let backSlash = S.indexOf(num3, bChar);
		if (forwardSlash = -1 & backSlash = -1) {
			let n = num.intValue();
			return Fraction.new(n, 1);
		}
		if (forwardSlash > -1) {
			let delimiter = forwardSlash;
		} else {
			let delimiter = backSlash;
		}
		let nS = S.substr(num, 0, delimiter);
		let start = delimiter + 1;
		let end = String.length(num);
		let dS = S.substr(num, start, end);

		let n = nS.intValue();
		let d = dS.intValue();
		return Fraction.new(n, d);
	}

	method String toString(){
		var String appended, n, d;

		let n = String.new(8);
		let d = String.new(8);

		do n.setInt(signedNumerator());
		do d.setInt(denominator);
		if (denominator = 1){
			return n;
		} else {
			let appended = S.append3(n, "/", d);
			return appended;
		}
	}

	method int toInt() {
		var int a;
		if (numerator = 0){
			return 0;
		}
		let a = numerator/denominator;
		return a;
	}

	method String toDecimal (int places) {
		var int numLength, remainder, i, dividend, decIndex, j, digit;
		var String numString,  answer, c, dividendString;

		let numString = String.new(12);
		let dividendString = String.new(12);
		let answer = String.new(12);
		let remainder = 0;
		let dividend = 0;

		do numString.setInt(numerator);
		let numLength = numString.length();

		let i = 0;
		while (i < (numLength + places)) {
			if (i < numLength) {
				let c = S.substr(numString, i, i + 1);
				let digit = c.intValue();
			} else {
				let digit = 0;
			}

			if (i = numLength) {
				let answer = S.append(answer, ".");
			}
			let dividend = (digit + (remainder * 10)) / denominator;
			do dividendString.setInt(dividend);
			let answer = S.append(answer, dividendString);
			let remainder = digit + (remainder * 10) - (dividend * denominator);
			let i = i + 1;
		}

		let decIndex = S.indexOf(answer, 46);
		let j = 0;
		while (j < (decIndex - 1)) {
			let c = S.substr(answer, 0, 1);
			if (S.equals(c, "0") = true) {
				let answer = S.substr(answer, 1, answer.length());
				let j = j + 1;
			} else {
				let j = decIndex;
			}
		}

		if (~pos){
			let answer = S.append("-", answer);
		}

		return answer;
	}

	method void checkValid() {
		if(denominator > 9999 | denominator < -9999 | numerator > 9999 | numerator < -9999 | denominator = 0){
			do Out.ln("Invalid fraction");
		}
		return;
	}

	method boolean isGreaterThan(Fraction f2) {
		if (pos = f2.pos()){
			if (numerator = f2.numerator() & denominator = f2.denominator()){
				return false;
			}
			if (numerator * f2.denominator() < f2.numerator() * denominator){
				return false;
			}
			return true;
		}
		return pos;
	}

	method boolean isLessThan(Fraction f2) {
		if (pos = f2.pos()){
			if (numerator = f2.numerator() & denominator = f2.denominator()){
				return false;
			}
			if (numerator * f2.denominator() > f2.numerator() * denominator){
				return false;
			}
			return true;
		}
		return ~pos;
	}

	// Computes the greatest common divisor of the given integers.
	function int gcd(int a, int b) {
		var int r;
		while (~(b = 0)) {             // applies Euclid's algorithm
			 let r = a - (b * (a / b));  // r = remainder of the integer division a/b
			 let a = b; let b = r;
		}
		return a;
	}

	/** Disposes this fraction. */
	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}
}
