/**
* A replacement integer class to handle negative numbers
*/
class Int {
	field boolean pos;
  field int num;

  constructor Int new(boolean isPos, int x){
    let pos = isPos;
    let num = x;
    return this;
  }

  /** accessors */
  method boolean pos(){ return pos; }
  method int num(){ return num; }

  method Int times(Int x){
     var int product;
     let product = x.num() * num;
     if (x.pos() = pos){
       return Int.new(true, product);
     }
     return Int.new(false, product);
  }

  function Int add(Int x, Int y){
    var Int sum;
    do Out.ln()
    let sum = Int.compute(true, x, y);
    return sum;
  }

  function Int subtract(Int x, Int y){
    var Int diff;
    let diff = Int.compute(false, x, y);
    return diff;
  }

	/** Adds or subtracts two integers following rules of negatives */
  function Int compute(boolean add, Int a, Int b){
    var int x, y, bigger, smaller, result;
    var boolean biggerPos, smallerPos, posPos, posNeg, negPos, negNeg;

    let x = a.num();
    let y = b.num();
    let smallerPos = false;
    let biggerPos = false;
    let posPos = false;
    let posNeg = false;
    let negPos = false;
    let negNeg = false;
    let result = 0;

    if (((x = 0) & (y = 0)) | ((x = y) & ((add & ~(a.pos() = b.pos())) | (~add & (a.pos() = b.pos()))))){
      do Out.ln("returning 0!");
      return Int.new(true, result);
    }

    if (x > y){
      let bigger = x;
      let biggerPos = a.pos();
      let smaller = y;
      let smallerPos = b.pos();
    } else {
      let bigger = y;
      let biggerPos = b.pos();
      let smaller = x;
      let smallerPos = a.pos();
    }
    if (biggerPos){
      if (smallerPos){
        let posPos = true;
      } else {
        let posNeg = true;
      }
    } else {
      if (smallerPos){
        let negPos = true;
      } else {
        let negNeg = true;
      }
    }

    let result = bigger + smaller;
    if((add & posPos) | (~add & ((posNeg & ~(x < y)) | (negPos & (x < y))))){
      return Int.new(true, result);
    }
    if((add & negNeg) | (~add & ((posNeg & (x < y)) | (negPos & ~(x < y))))){
      return Int.new(false, result);
    }

    let result = bigger - smaller;
    if((add & posNeg) | (~add & ((negNeg & (x < y)) | (posPos & (x > y))))){
      return Int.new(true, result);
    }
    if((add & negPos) | (~add & ((negNeg & (x > y)) | (posPos & (x < y))))){
      return Int.new(false, result);
    }
    do Out.ln("invalid Int Calculation");
//    do Sys.halt();
    return Int.new(true, 10000);
  }

  method boolean equals(Int b){
    return (pos = b.pos()) & (num = b.num());
  }

  method boolean isLessThan(Int b){
    if (pos = b.pos()){
      if (pos){
        return (num < b.num());
      }
      return (num > b.num());
    }
    if (pos){
      return false;
    }
    return true;
  }

  method boolean isGreaterThan(Int b){
    return ~(isLessThan(b) | equals(b));
  }

//  function String stringOf(Int x){
//	  var String numS;
//	  let numS = String.new(20);
//	  do numS.setInt(x.num());
//	  if (x.pos()) {
//	    return numS;
//	  } else {
//	    return S.append("-", numS);
//	  }
////	return "dummyInt";
//  }

  method String toString(){
  var String numS, mnumS, sign;
  let sign = "-";
      let numS = String.new(20);
    	  do numS.setInt(num);
    	  if (pos) {
    	    return numS;
    	  } else {
    	    let mnumS = S.append(sign, numS);
    	    return mnumS;
    	  }
  }

   method void dispose() {
      do Memory.deAlloc(this);
      return;
    }
}
